#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

const uint num_particals = 1*1024 * 1024;
const uint GRID_DIM = 1024;
const uint grid_size = GRID_DIM * GRID_DIM;
const uint LDSSize = 128;

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout ( binding = 1, rgba8 ) uniform writeonly image2D resultImage;

struct Particle {
    vec3 pos;
    uint cell;
    vec3 velocity;
    uint state;
    float timeInfected;
    uint cellCount;
};

layout(std430, binding = 2) buffer ParticleObject{
    Particle particleArray[num_particals];
};

layout(std430, binding = 3) buffer gridCountObject{
    uint gridCountArray[grid_size];
};

layout(std430, binding = 5) buffer coherent gridScratchObject{
    uint gridScratchArray[];
};



const int HEIGHT = 1080;
const int WIDTH = 1920;
const float EPS = 0.000001;

shared uint sdata[LDSSize];

uint addFlag(uint value, uint flag) {
    return value + (flag << 30);   
}

uint getFlag(uint value) {
    return (value >> 30) & 3u;
}
    

uint removeFlag(uint value) {
    return value & ~(3u << 30);
}

const float dt = 0.001;
void main()
{   

    if (gl_LocalInvocationID.x == 0) {
        sdata[0] = atomicAdd(gridScratchArray[grid_size - 1], 1);
    }
    memoryBarrierShared();
    barrier();
    uint workgroupId = sdata[0];

    // get data from array and scan in blocks of subgroup size in registers
    uint sumIdx = 0;
    sumIdx = gridCountArray[workgroupId * gl_WorkGroupSize.x + gl_LocalInvocationID.x];    
    uint lastInGroup = gridCountArray[workgroupId * gl_WorkGroupSize.x + (gl_SubgroupID + 1) * gl_SubgroupSize - 1];
    sumIdx = subgroupExclusiveAdd(sumIdx);    

    // copy end element of subgroup to shared
    if (gl_SubgroupInvocationID == gl_SubgroupSize - 1) {
        sdata[gl_SubgroupID] = sumIdx + lastInGroup;        
    }    
    memoryBarrierShared();
    barrier();

    // scan in shared memory, again using subgroups
    if (gl_LocalInvocationIndex.x < gl_NumSubgroups) {
       uint sharedSum = 0;
       sharedSum = sdata[gl_LocalInvocationIndex.x];
       sharedSum = subgroupExclusiveAdd(sharedSum);       
       sdata[gl_LocalInvocationIndex.x] = sharedSum;       
    }
    memoryBarrierShared();
    barrier();

    // update each subgroup block with the shared memory offset
    uint blockSum = sdata[gl_SubgroupID];    
    sumIdx += blockSum;    
    gridCountArray[workgroupId * gl_WorkGroupSize.x + gl_LocalInvocationID.x] = sumIdx; 

    // save the sum of elements in the workgroup to update the other workgroups in the second pass
    if (gl_LocalInvocationIndex.x == gl_WorkGroupSize.x - 1) {
        sdata[0] = sumIdx + lastInGroup;
        gridScratchArray[workgroupId] = addFlag(sumIdx + lastInGroup, 1);            
    }

    
    uint inclusive = 0;    
    for (int i=int(workgroupId) - 1; i >= 0;i--) {        
        uint value;
        uint flag;
        do {
            memoryBarrier();
            value = gridScratchArray[i];
            flag = getFlag(value);              
        }  while (flag == 0);
        inclusive += removeFlag(value);                
        if (flag == 2) break;
    }

    gridCountArray[workgroupId * gl_WorkGroupSize.x + gl_LocalInvocationID.x] += inclusive;

    gridScratchArray[workgroupId] = addFlag(inclusive + sdata[0], 2);
    
    
    
}

